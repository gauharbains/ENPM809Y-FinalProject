<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Final Project: Mouse Algorithm Options</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Final Project
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Objective of this project is to  navigate a robot through a maze to reach the center of the maze.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_Simulator_mms_old_v2_wiki_Mouse_Algorithm_Options.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Mouse Algorithm Options </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>There are a few options that are available to mouse algorithms. They are implemented as virtual methods in the <code><a class="el" href="class_i_mouse_algorithm.html">IMouseAlgorithm</a></code> class. That is, the default options are defined in <code>src/mouse/IMouseAlgorithm.cpp</code>. If you wish to use values other than the defaults, should override the virtual methods in you algorithm (which should inherit from <a class="el" href="class_i_mouse_algorithm.html">IMouseAlgorithm</a>). For instance, suppose your algorithm's <code>.h</code> and <code>.cpp</code> file looked like to following, respectively:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// LeftWallFollow.h</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#pragma once</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;#include &quot;../IMouseAlgorithm.h&quot;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;namespace leftWallFollow {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;class LeftWallFollow : public IMouseAlgorithm {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;public:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    void solve(</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        int mazeWidth, int mazeHeight, bool isOfficialMaze,</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        char initialDirection, sim::MouseInterface* mouse);</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;private:</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    void leftWallFollowStep(sim::MouseInterface* mouse);</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;};</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;} // namespace leftWallFollow</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// LeftWallFollow.cpp</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#include &quot;LeftWallFollow.h&quot;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;namespace leftWallFollow {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;void LeftWallFollow::solve(</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;        int mazeWidth, int mazeHeight, bool isOfficialMaze,</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;        char initialDirection, sim::MouseInterface* mouse) {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    while (true) {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;        leftWallFollowStep(mouse);</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    }</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;}</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;void LeftWallFollow::leftWallFollowStep(sim::MouseInterface* mouse) {</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    if (!mouse-&gt;wallLeft()){</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        mouse-&gt;turnLeft();</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    }</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;    while (mouse-&gt;wallFront()){</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        mouse-&gt;turnRight();</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    mouse-&gt;moveForward();</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;}</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;} // namespace leftWallFollow</div></div><!-- fragment --><p>If you wanted to change the value of the <code>declareWallsOnRead</code> option, you would override that method in <code><a class="el" href="class_left_wall_follow.html">LeftWallFollow</a></code>, like:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// LeftWallFollow.h</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#pragma once</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;#include &quot;../IMouseAlgorithm.h&quot;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;namespace leftWallFollow {</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;class LeftWallFollow : public IMouseAlgorithm {</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;public:</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    bool declareWallOnRead() const; // Note the &quot;const&quot;</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    void solve(</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        int mazeWidth, int mazeHeight, bool isOfficialMaze,</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        char initialDirection, sim::MouseInterface* mouse);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;private:</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    void leftWallFollowStep(sim::MouseInterface* mouse);</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;};</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;} // namespace leftWallFollow</div></div><!-- fragment --><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// LeftWallFollow.cpp</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#include &quot;LeftWallFollow.h&quot;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;namespace leftWallFollow {</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;bool LeftWallFollow::declareWallOnRead() const { // Note the &quot;const&quot;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    return true;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;}</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;void LeftWallFollow::solve(</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;        int mazeWidth, int mazeHeight, bool isOfficialMaze,</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;        char initialDirection, sim::MouseInterface* mouse) {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    while (true) {</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;        leftWallFollowStep(mouse);</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;    }</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;}</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;void LeftWallFollow::leftWallFollowStep(sim::MouseInterface* mouse) {</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    if (!mouse-&gt;wallLeft()){</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;        mouse-&gt;turnLeft();</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;    }</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    while (mouse-&gt;wallFront()){</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;        mouse-&gt;turnRight();</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    }</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;    mouse-&gt;moveForward();</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;}</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;} // namespace leftWallFollow</div></div><!-- fragment --><p>One important thing to remember is that all of the mouse algorithm options are implemented as const methods. If you forget to put <code>const</code> after the method name, the option you specified won't have any effect.</p>
<p>Right now, the algorithm options are evaluated at either the start of the simulator, or throughout the simulation. That is, the static options are all evaluated only once, and changing the return value of those functions won't do anything. However, the dynamic options are evaluated continuously, which means that you can do fancy things like change the return values of the functions depending on the state of your algorithm. See the <code><a class="el" href="class_left_wall_follow.html">LeftWallFollow</a></code> algorithm for an example of how to change the value of these options at runtime.</p>
<p>Here are all of the options available to mouse algorithms:</p>
<h3>Static options for both interfaces</h3>
<h6><code>virtual std::string mouseFile() const;</code></h6>
<p>The mouse file, relative to <code>res/mouse/</code>, which specifies the physical properties of the mouse. For more info, see [Mouse Spec File](Mouse Spec File).</p>
<h6><code>virtual std::string interfaceType() const;</code></h6>
<p>The interface type of the mouse algorithm. Can be either <code>DISCRETE</code> or <code>CONTINUOUS</code>. For more information, see [DISCRETE vs CONTINUOUS](DISCRETE vs CONTINUOUS).</p>
<h6><code>virtual std::string initialDirection() const;</code></h6>
<p>The direction that the mouse should be facing at the start of executing. Can be one of:</p><ul>
<li><code>NORTH</code> - facing north</li>
<li><code>EAST</code> - facing north</li>
<li><code>SOUTH</code> - facing north</li>
<li><code>WEST</code> - facing north</li>
<li><code>OPENING</code> - facing either north or east, whichever is the opening, if one exists</li>
<li><code>WALL</code> - facing either north or east, whichever is the wall, if one exists</li>
</ul>
<h6><code>virtual int tileTextNumberOfRows() const;</code></h6>
<p>The number of rows of text per tile. It's a good idea to keep this as small as possible, since it's expensive to draw lots of characters on every tile. See [Tile Text](Tile Text) for more information.</p>
<h6><code>virtual int tileTextNumberOfCols() const;</code></h6>
<p>The number of columns of text per tile. It's a good idea to keep this as small as possible, since it's expensive to draw lots of characters on every tile. See [Tile Text](Tile Text) for more information.</p>
<h3>Dynamic options for both interface types</h3>
<h6><code>virtual bool allowOmniscience() const;</code></h6>
<p>Whether or not to allow the algorithm to call the omniscience methods, which give the algorithm access to information it wouldn't normally have, including</p><ul>
<li>Current mouse position</li>
<li>Current mouse rotation</li>
</ul>
<h6><code>virtual bool automaticallyClearFog() const;</code></h6>
<p>Whether or not the simulator should automatically clear tile fog when the mouse enters a new tile. See [Tile Fog](Tile Fog) for more information.</p>
<h6><code>virtual bool declareBothWallHalves() const;</code></h6>
<p>Whether or not declaring one side of a wall should cause the other side of the wall to also be declared. For example, when this is true, declaring the north wall of tile (0,1) would also cause the south wall of tile (0,2) to be declared similarly. The reason that this isn't the default behavior is because most algorithms store their wall information on a tile by tile basis. By forcing the algorithm to explicitly declare both walls, we increase the odds that the internal representation of the walls stays consistent. See [Tile Walls](Tile Walls) for more information.</p>
<h6><code>virtual bool setTileTextWhenDistanceDeclared() const;</code></h6>
<p>Whether or not the tile text should be set to the declared distance, if and when a tile distance is declared. See [Tile Text](Tile Text) and [Tile Distance](Tile Distance) for more information.</p>
<h6><code>virtual bool setTileBaseColorWhenDistanceDeclaredCorrectly() const;</code></h6>
<p>Whether or not the tile base color should be set to something other than the default tile base color, if and when the distance is declared correctly. This option is used to give visual feedback about when the tile distances are known to the mouse algorithm. For more information, see [Tile Color](Tile Color) and [Tile Distance](Tile Distance).</p>
<h3>Static options for the DISCRETE interface</h3>
<h6><code>virtual double wheelSpeedFraction() const;</code></h6>
<p>The fraction of the maximum wheel speed that should be used for movement in <code>DISCRETE</code> mode. For most mice, this can just be <code>1</code>. However, some mice, like <code>megaMouse.xml</code>, have very high maximum speeds, that aren't suitable for regular maze traversal. You can use this method to specify the fraction of the maximum wheel speed that should be used. See [Mouse Spec File](Mouse Spec File) for more information.</p>
<h3>Dynamic options for the DISCRETE interface</h3>
<h6><code>virtual bool declareWallOnRead() const;</code></h6>
<p>Whether or not the walls of the maze should be declared whenever the algorithm checks for the existence of the wall. Normally, tile wall declaration is used to convey information to the programmer about the mouse's knowledge as it explores and learns the maze. This option allows us to show to users that a wall has been inspected, without necessarily having to keep track of exactly which walls we're inspecting. For example, the wall following algorithms use this to give visual information about where the mouse has been. See [Tile Walls](Tile Walls) for more information.</p>
<h6><code>virtual bool useTileEdgeMovements() const;</code></h6>
<p>Whether or not the discrete movements should start and stop on tile edges, as opposed to tile centers. If <code>true</code>, you must use only the special <code>DISCRETE</code> methods that are outlined in [The Complete Mouse API](The Complete Mouse API). If <code>false</code>, you must use only the basic <code>DISCRETE</code> methods outlined in the same document. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
