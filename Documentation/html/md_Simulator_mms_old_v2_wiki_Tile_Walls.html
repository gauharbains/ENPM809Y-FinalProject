<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Final Project: Tile Walls</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Final Project
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Objective of this project is to  navigate a robot through a maze to reach the center of the maze.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_Simulator_mms_old_v2_wiki_Tile_Walls.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tile Walls </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Tile walls are a mechanism for conveying the wall information of the mouse algorithm. It's a way of visually displaying exactly where the mouse thinks walls are, and where it thinks they are not. This is extremely valuable information for the user/programmer to have, and it much more intuitive than trying to print/display the wall information textually.</p>
<p>Tile walls are "declared" by the algorithm. That is, the algorithm is responsible for declaring (to the simulator) that it thinks that there is a wall in a particular location. The simulator can then change the color of the wall place-holder according to whether or not the wall declaration was correct or incorrect, giving instantaneous feedback to users about the proper or improper functioning of the algorithm.</p>
<p>The API for declaring tile walls is as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void declareWall(int x, int y, char direction, bool wallExists);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;void undeclareWall(int x, int y, char direction);</div></div><!-- fragment --><p>The best way to use wall declarations effectively is to couple them together with the logic that updates the algorithm's internal representation of the maze. That is, in order for a mouse to find the center of the maze, it needs to keep track of the walls. Most people store this information in an array or vector. As the mouse explores the maze, it updates the information in the array/vector. In order to ensure that the walls are declared when the internal wall information is updated, it's wise to make a helper function that updates the internal representation and declares walls. Then, instead of updating the array/vector directly, you can just call the helper function. And then you can be sure that the wall declaration visualization will always match your mouse's internal representation of the maze.</p>
<p>For example:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;{c++}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;// Suppose we have a 2D array of myTileStruct objects (which store wall info)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;myTileStruct maze[16][16];</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// Don&#39;t do this everywhere in the codebase - it&#39;s too difficult to remember to</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// call declareWall each time you update maze</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;maze[0][0].wallNorth = true;</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;mouse-&gt;declareWall(0, 0, &#39;n&#39;, true);</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;// Instead, define a helper function like this</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;void setWall(int x, int y, char dir, bool isWall) {</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    // Update the internal representation</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;    switch (dir) {</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;        case &#39;n&#39;: // north</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;            maze[0][0].wallNorth = isWall;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;            break</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;        ...</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    }</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    // Declare the wall</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    mouse-&gt;declareWall(x, y, dir, isWall);</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;}</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;// And then use it like this, so that you don&#39;t have to remember to call</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;// declareWall each and every time you update the internal state of the maze.</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;setWall(0, 0, &#39;n&#39;, true);</div></div><!-- fragment --><p>A good example of an algorithm that does this is <code>MackAlgo</code>. Check out <code>src/mouse/mackAlgo/Cell.cpp</code> for some code that follows this pattern.</p>
<h3>Toggling Wall Truth</h3>
<p>Walls truth may be on or off by default, based on the simulator [Parameters](Parameters). As mentioned in [Keys](Keys), you can toggle between seeing the wall truth and the algorithm's internal representation of the maze by pressing "t" while the simulation is running.</p>
<h3><code>declareWallsOnRead()</code></h3>
<p>Just in case you may have missed it, there's a [Mouse Algorithm Option](Mouse Algorithm Options) that allows walls to be declared automatically whenever their existence is queried. That is, if you return <code>true</code> from <code>declareWallsOnRead()</code>, then whenever you call any of the <code>DISCRETE</code> API methods <code>wallFront()</code>, <code>wallLeft()</code>, or <code>wallRight()</code>, the wall that you inspected will automatically be declared. The use case for this is something like a wall-following robot, where the wall declarations are used to convey information about where the robot has been, and not necessarily the internal representation of the maze. In general, it's best to declare the walls manually so that you can have more confidence that the walls displayed correlate to the internal representation of the maze. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
